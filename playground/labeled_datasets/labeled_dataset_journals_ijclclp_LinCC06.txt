Named entities [MUC 1998], which denote persons, locations, organizations, etc., are common foci of searchers. __label__=other
Thompson and Dozier [1997] showed that named entity recognition (NER) could improve the performance of information retrieval systems. __label__=other
Capturing named entities is challenging due to their flexible formulation and novelty. __label__=other
The issues behind speech recognition make named entity recognition more challenging on the spoken level than on the written level. __label__=other
This paper focuses on a special type of named entities, called transliteration names. __label__=objective
They describe foreign people, places, etc. __label__=other
Spoken transliteration name recognition is useful for many applications. __label__=other
For example, cross language image retrieval via spoken queries aims to employ the latter in one language to retrieve images with captions in another language [Lin et al. __label__=other
2004]. __label__=other
In the past, Appelt and Martin [1999] adapted the TextPro system to process transcripts generated by a speech recognizer. __label__=other
Miller et al. __label__=other
[2000] analyzed the effects of out-of-vocabulary errors and the loss of punctuation on name finding in automatic speech recognition. __label__=other
Huang and Waibel [2002] proposed an adaptive method of named entity extraction for the meeting understanding. __label__=other
Chen [2003] dealt with spoken cross-language access to image collections. __label__=other
The coverage of a lexicon is one of the major issues in spoken transliteration name access. __label__=other
Recently, researchers are interested in using the Web, which provides a huge collection of up-to-date data, as a corpus. __label__=other
Keller and Lapata [2003] employed the Web to obtain frequencies for bigrams that are unseen in a given corpus. __label__=other
Named entities are important objects in web documents. __label__=other
Building named entity relationship chains from the web is an important task. __label__=other
Matsuo et al. __label__=other
[2004] found social networks of trust from related web pages. __label__=other
Google sets 1 extracts named entity from web pages by inputting a few named entities. __label__=other
For some emerging applications like personal name disambiguation [Fleischman and Hovy 2004] [Mann and Yarowsky 2003], social chain finding [Bekkerman and McCallum 2005] [Culotta et al. __label__=other
2004] [Raghavan et al. __label__=other
2004], etc., glossary-based representations of named entities are not enough. __label__=other
For collecting transliteration names and building a bi-character language model, we propose a named entity (NE) ontology generation engine, called the X NE -Tree engine. __label__=objective
This engine produces relational named entities by given a seed. __label__=method
The engine uses Google to incrementally extract high co-occurrence named entities from related web pages and those named entities have similar relational properties with the seed. __label__=method
In each iterative step, the seed will be replaced by its siblings or descendants, which form new seeds. __label__=method
In this way, the X NE -Tree engine will build a tree structure as follows with the original seed as a root. __label__=method
Spoken Transliteration Name Access In this paper, we discuss using the Web as a live dictionary for recognizing spoken transliteration names and employ the fuzzy search capability of Google to retrieve relevant web page summaries. __label__=objective
In section 2, we sketch the steps in our method. __label__=other
In section 3, we discuss using PAT trees to learn patterns from the Web dynamically and to correct recognition errors. __label__=other
Section 4 shows the experiments, which are the ASR model with/without the recovery mechanism. __label__=other
Section 5 presents the X NE -Tree named entity ontology engine and our experimental results. __label__=other
In section 6, we make concluding remarks.  __label__=other
The spoken transliteration name recognition system shown in Figure 1accepts a speech signal denoting a foreign named entity and converts it into a character string. __label__=other
It is composed of the following four major stages. __label__=other
Stages (1) and (2) consist of the fundamental tasks in speech recognition. __label__=other
In the Stages (3) and (4), speech-to-text errors are corrected by using the Web. __label__=other
Figure 1. __label__=other
Stage in transliteration name recognition (1) First, we employ the HTK 2 and SRILM 3 toolkits to build speech recognition models. __label__=software
For each speech signal, we use the model to get a syllable lattice. __label__=method
(2) Then, the syllable lattice is mapped into a character lattice by using a mapping table. __label__=method
The mapping table is a syllable-to-character mapping. __label__=other
Top-N character strings are selected from the character lattice by using Viterbe algorithm and a bi-character model which is trained from a transliteration name corpus. __label__=method
Such character strings will be called ASR strings in the following. __label__=other
(3) Next, each ASR string is regarded as a query and is submitted to a web search engine like Google. __label__=method
From the top-N search result, we select higher frequency patterns from a PAT tree structure. __label__=method
The PAT tree [Chien 1997] [Gonnet et al. __label__=other
1992], which was derived from the Patricia tree, can be employed to extract word boundary and key phrases automatically. __label__=other
Because we employ the PAT tree to extract patterns, the patterns will be called PAT candidates in the following. __label__=other
A PAT tree example, " 湯姆漢克斯湯姆克魯斯喬治克魯尼 " in MS950 encoding, is shown in Figure 2. __label__=other
The circles represent semi-infinite string numbers. __label__=other
The number above each circle denotes the length, which indicates the first different bit of the character strings recorded in the sub-trees. __label__=other
In this example, the longest patterns are for " 克魯 " and " 湯姆 " on nodes (7, 12) and (0, 5), with lengths of 33 and 34 bits, respectively. __label__=other
The second longest patterns are for " 克 " , " 魯 " , " 姆 " and " 斯 " on nodes (3, 7, 12), (8, 13), (1, 6) and (4, 9), with lengths of 16, 17, 18 and 18 bits, respectively. __label__=other
Figure 2. __label__=other
An example of extracting longest length pattern and its frequency (4) Finally, the PAT candidates of all the ASR strings are merged together and ranked based on their number of occurrences and similarity scores. __label__=other
Candidates with the highest ranks are regarded as the recognition results for a spoken transliteration name. __label__=other
Consider the example shown in Figure 3. __label__=other
The Chinese speech signal is a transliteration name, " 湯姆克魯斯 " , in Chinese, which denotes the name of the movie star " Tom Cruise. " __label__=other
The lattice shows different combinations of syllables. __label__=other
Each syllable corresponds to several Chinese characters. __label__=other
For example, " ke " is converted into " 克 " , " 柯 " , " 科 " , " 可 " , " 喀 " , " 刻 " , etc. __label__=other
The ASR strings " 塔莫克魯斯 " , " 塔門克魯斯 " , " 塔莫柯魯斯 " , etc. __label__=other
are selected from the Spoken Transliteration Name Access character lattice. __label__=other
Through Google fuzzy search using the query " 塔 莫 克 魯 斯 " , some summaries of Chinese web pages are obtained and shown in Figure 4. __label__=other
Although the common transliteration of " Tom Cruise " in Chinese is " 湯姆克魯斯 " , which is different from the query " 塔莫克魯斯 " , fuzzy matching using Google can still identify relevant snippets containing the correct transliteration. __label__=other
We will call this operation " recognition error recovery using the Web " in the following. __label__=other
(5) ... 電影節最具看點的明星當然非妮可基德曼與湯姆克魯斯有望在水城的戲劇性重逢 莫屬。 Figure 4. __label__=other
Summaries obtained through fuzzy search for the query " 塔莫克魯斯 " In the above examples, each partial matching part is enclosed in a rectangle symbol and the correct transliteration name is underlined. __label__=other
Summaries (1), (4) and (5) mention the movie star " 湯姆克魯斯 " (Tom Cruise) and summaries (2) and (3) mention a football star, " 克魯斯 " (Cruz). __label__=other
Figure 3shows that PAT patterns like " 聖塔克魯斯 " , " 湯姆克魯斯 " , " 姆克魯斯演 " , etc. __label__=other
are proposed. __label__=other
After merging and ranking are performed, the possible recognition results are " 湯姆克魯斯 " , " 洛普克魯茲 " , " 聖塔克魯茲 " , etc. __label__=other
Speech Input 湯姆克魯斯  <Equation_0>  __label__=other
The error recovery module tries to select higher frequency patterns from the Web search results and substitute the speech recognition results of Stages 1 and 2 (shown in Section 2) with the pattern. __label__=other
In this approach, Web search results obtained with an ASR string are placed in a PAT tree, and PAT candidates are selected from the tree. __label__=other
Two points are worth noting. __label__=other
A PAT candidate should occur many times in the PAT tree and should be similar to the ASR string. __label__=other
The frequency, Freq, of a PAT candidate can be computed easily based on the PAT tree structure. __label__=other
The similarity between a PAT candidate and an ASR string is modeled by edit distance, which is the minimum number of insertions, deletions and substitutions needed to transform one character string (ASR) into another string (PAT). __label__=method
The smaller number is, the more similar they are. __label__=other
The similarity score, between an ASR string and a PAT string, is the frequency of the PAT string minus their number of edit operations. __label__=other
Finally, the score of a PAT string relative to an ASR string is defined as follows:  <Equation_1> Score ASR PAT Freq PAT Dis ce ASR PAT  <Equation_2>  <Equation_3> It is computed through weighted merging of the frequency of the PAT string and by using the similarity between the ASR string and PAT string. __label__=method
This value determines if the ASR string will be replaced by the PAT string. __label__=other
In the above example, Freq(湯姆克魯斯)=43 and Distance (塔莫克魯斯, 湯姆克魯斯)=2.  __label__=other
The speech input to the transliteration name recognition system is a Chinese utterance. __label__=other
We employed 51,111 transliteration names to train the bi-character language model discussed in Section 2. __label__=other
In the experiments, the test data include 50 American state names, 29 names of movie stars from the 31 st Annual People's Choice Awards (http://www.pcavote.com), and 21 names of NBA stars from the 2005 NBA All Star Team (http://www.nba.com/allstar2005/). __label__=dataset
The 50 American state names are not very active on the Web. __label__=other
In contrast, the 50 names of stars are very active. __label__=other
The test set is different from the training data set, so it is an open test. __label__=other
Because there may be more than one transliteration for a foreign named entity, the answer keys are manually prepared. __label__=other
For example, " Arizona " has four possible transliterations in Chinese: " 亞利桑納 " , " 亞歷桑納 " , " 亞利桑那 " , and " 亞歷桑 那 " . __label__=other
On average, there are 1.9 Chinese transliterations for a foreign name in our test set. __label__=other
Appendix A lists the name test set and its answer keys. __label__=other
As explained in Section 2, the transliteration name recognition system is composed of four major stages. __label__=other
Stages 1 and 2 include the fundamental speech recognition tasks, and Stages 3 and 4 comprise the error Spoken Transliteration Name Access recovery task. __label__=method
To examine the effects of these two parts, we will evaluate them separately in the following two subsections. __label__=other
We assume that correct syllables have been identified in the speech recognition task. __label__=other
We simulate this assumption by transforming all the characters in the answer keys into syllables. __label__=other
Then, in Stage 2, we map the syllable lattice to obtain a character lattice. __label__=other
A total of 50 ASR strings are extracted from the character lattice in Stage 2 and submitted to Google. __label__=other
Finally, the best 10 PAT candidates are selected. __label__=other
We use the MRR (Mean Reciprocal Rank) [Voorhees 1999] and recall rate to evaluate the performance. __label__=method
The MRR represents the average rank of the correctly identified transliteration names among in the proposed candidates and it is defined as follow:  <Equation_4> where M is the total number of test cases ; r i equals 1/rank i if rank i > 0 and r i is 0 if no answer is found. __label__=other
The rank i is the rank of the first correct answer for the i th test case. __label__=other
That is, if the first correct answer is ranked 1, then the score is 1/1; if it is ranked 2, the score is 1/2, and so on. __label__=other
The MRR value is between 0 and 1. __label__=other
The inverse of the MRR denotes the average position of the correct answer in the proposed candidate list. __label__=other
The higher the MRR value is, the better the performance is. __label__=other
The recall rate is the number of correct references divided by M. It indicates how many transliteration names are correctly recognized. __label__=method
Table 1summarizes the experimental results obtained with models without/with the error recovery procedure. __label__=other
With the " ASR only " model, the top 10 ASR strings produced in Stage 2 are regarded as answers. __label__=other
This model does not employ the error recovery procedure. __label__=other
The recall rate is 0.79 and the MRR is 0.50. __label__=result
That is, 79 of 100 transliteration names are recognized correctly, and they appear in the first 2 (=1/0.50) position. __label__=result
In contrast, the " ASR + Web " model utilizes the error recovery procedure. __label__=other
PAT candidates extracted from the Web are selected in Stage 4. __label__=other
The recall rate is 0.90 and the MRR is 0.88. __label__=result
A total of 90 transliteration names are recognized correctly, and they appear in the first 1.13 (=1/0.88) position on average. __label__=result
In other words, when they are recognized correctly, they are always the top 1. __label__=other
Compared with the first model, the recall rate is increased 13.92%. __label__=result
As for the third model, i.e., the " ASR/Pre-removed + Web " model, we try to evaluate the error recovery ability. __label__=other
The correct transliteration names appearing in the set of ASR strings are removed. __label__=other
That is, all of the ASR strings contain at least one incorrect character. __label__=other
In such cases, the recall rate is 0.59 and the MRR is 0.48. __label__=result
This means that 59 transliteration names are recovered, and they appeared in the first 2.08 (=1/0.48) position on average. __label__=result
We further examine the number of errors produced by the " ASR/Pre-removed + Web " model to study the error tolerance when using the Web. __label__=other
Table  2shows the lengths of the transliteration names (in the rows), and the number of matching characters (in the columns). __label__=other
For a transliteration name of length l, the number of matching characters is 0 to l. Each cell denotes how many strings belong to the specific category. __label__=other
For example, before error recovery, there are 6, 25, 90, 184, and 0 strings of length 4, which have 0, 1, 2, 3, and 4 characters matching the corresponding answer keys, respectively. __label__=other
After error recovery, there are 19, 52, 66, 62, and 106 strings of length 4, which have 0, 1, 2, 3, and 4 characters matching the answer keys, respectively. __label__=other
In other words, the recovery procedure corrects some wrong characters. __label__=other
The number of 1-character (2-character) errors decreased from 184 (90) to 62 (66), and total number of correct strings are increased from 0 to 106. __label__=result
Table 3shows the effects of the error position (in the rows) and the string length (in the columns). __label__=other
A total of 0, 2, 106, 137, and 22 utterances recover 1 character with length 2, 3, 4, 5, and 6, respectively. __label__=other
A total of 0, 0, 3, 4, and 5 utterances recover 2 characters with length 2, 3, 4, 5, and 6, respectively. __label__=other
No utterances can recover over 3 characters. __label__=other
The cell denotes how many strings can be recovered under the specific position and length. __label__=other
For example, a total of 37, 35, 20, and 17 errors for strings of length 4 appearing at positions 1, 2, 3, and 4, respectively, can be recovered by using the Web. __label__=other
In the experiments, 0% (=0/34), 1.80% (=2/111), 35.74% (=109/305), 46.84% (=141/301), and 39.71% (=27/68) of the strings of length 2, 3, 4, 5, and 6 can be recovered, respectively. __label__=result
The 34 is the number of the PAT candidates with length 2. __label__=other
Similarly, the 111, 305, 301, and 68 are the number of the PAT candidates with length 3, 4, 5, and 6. __label__=other
As for length, the longer strings facilitate better recovery than the shorter strings. __label__=other
Another results show that 30.82% (=86/279), 29.75% (=83/279), 17.20% (=48/279), 15.77% (=44/279), 6.09% (=17/279), and 0.36% (=1/279) of the strings with incorrect character appearing at positions 1, 2, 3, 4, 5 and 6 can be recovered, respectively. __label__=result
The 279 is the number of characters on which the 100 test data. __label__=other
Because the bi-character language model proceeds from the left side to the right side, the errors occurring at the beginning are easier to recover than those at the end. __label__=other
The set of 100 transliteration names discussed in Section 4.1 are spoken by 2 males and 1 female, so 300 transliteration names are recorded. __label__=other
We employ HTK and SRILM to get the best 100 syllable lattices (N-Best, N=100). __label__=method
The TCC-300 dataset for Mandarin is used to train the acoustic models. __label__=dataset
There are 417 HMM models, and each one has 39 feature vectors. __label__=other
The syllable accuracy is computed as follows: (M-I-D-S)/M * 100%, where M is the number of correct syllables; I, D, and S denote the number of insertion, deletion, and substitution errors, respectively. __label__=other
The syllable accuracy is 76.57%. __label__=result
To estimate the character recovery ability, we consider the correct character number. __label__=other
The accuracy of the ASR only and ASR+Web models on the character level are computed as follows, respectively:  <Equation_5>  <Equation_6> where M is the total test number and K is the answer key number for test name i. __label__=other
A total of 50 ASR strings are extracted from the character lattice, and the best 50 PAT candidates are selected. __label__=other
Table 4shows the character level results. __label__=other
The " ASR+Web " model achieves 21.54% better performance than the " ASR Only " model on average. __label__=result
Table 5shows the word level results. __label__=other
The " ASR+Web " model using error recovery procedure improves the recall rate and the MRR of the " ASR Only " model from 0.20 and 0.07 to 0.42 and 0.31, respectively. __label__=result
In other words, the average ranks of the correct transliteration names move from the 14 th position (=1/0.07) to the 3 rd position (=1/0.31) after error recovery. __label__=result
Table 4. __label__=other
Performance on the character level ASR Only (Character Level Accuracy) ASR + Web (Character Level Accuracy) Web fuzzy search produces useful patterns for error recovery. __label__=result
Our fault tolerance experiments show that longer transliteration names have stronger tolerance than shorter transliteration names and that the incorrect characters appearing at the beginning of a transliteration name are relatively easier to correct than those appearing at the end. __label__=result
Thus, the improvement in the character level accuracy is helpful for the recovery mechanism, and vice versa.  __label__=result
For collecting transliteration names to build a bi-character language model, we propose using a named entity (NE) ontology generation mechanism, called the X NE -Tree engine. __label__=objective
Given a seed, the engine incrementally extracts relational named entities with the seed from related web pages and the output is a tree structure. __label__=other
Each node in the structure is a named entity (NE). __label__=other
Recognizing a named entity and calculating the relational property score with a seed are two crucial tasks. __label__=other
Firstly, we submit the given seed to a search engine and select the top N returned snippets. __label__=method
Then, we use the suffix tree to extract possible patterns automatically. __label__=method
The patterns, which are extracted based on the global statistic, may be impacted by the frequency variance of patterns with the same substrings [Yang and Li 2002]. __label__=method
Because our aim is to generate named entities, most of the max-duplicated strings can be filtered out by using a named entity Spoken Transliteration Name Access recognition (NER) system [Chen et al. __label__=objective
1998]. __label__=other
The NER system will re-segment a candidate pattern to obtain some substrings and give each substring a part of speech (POS) and a possible name tag. __label__=other
If any substring is tagged as a location, an organization, or a person by using an NER-POS server [Chen et al. __label__=other
1998], the candidate pattern is considered to be a named entity. __label__=other
Because prepositions frequently occur before/after a named entity, the suffix tree approach may introduce an incorrect boundary. __label__=other
Thus, we filter out substrings that have a preposition tag. __label__=other
Secondly, we calculate a relational property score, called the Co-Occurrence Double-Check score (CODC, for each extracted name entity (denoted Y i ) with a seed (denoted X). __label__=method
We postulate that X and Y i have a strong relationship if we can find Y i from X (a forward process) and find X from Y i (a backward process). __label__=other
The forward and backward processes form a double check operation. __label__=other
CODC(X, Y) is defined as follows:  <Equation_7> where f(X@Y i ) is the total number of occurrences of X in the top N snippets when query Y i is submitted to the search engine. __label__=other
Similarly, f(Y i @X) is the total number of occurrences of Y i in the top N snippets for query X; f(X) is the total number of occurrences of X in the top N snippets for query X, and f(Y) is the total number of occurrences of Y in the top N snippets of query Y. __label__=other
In each iterative step, Y i is added to a queue when the CODC (X,Y i ) value is larger than a threshold θ. __label__=other
Then, we get a new seed X from the queue. __label__=other
The CODC measure is best when α=0.15. __label__=result
The overall process is shown in Figure 5. __label__=other
Q u eu e T erm E x tra c tio n A n N E D o u b le C h e c k W rapp er N E R P O S T ag g in g N E O n to lo g y N ew S eed D ictio n ary Figure 5. __label__=other
Named entity ontology generation process When building a bi-character language model, we choose 100 seeds, which are the same 100 utterances described in Section 4. __label__=method
Here, we set a condition to control generation of the ontology. __label__=other
Each initial seed can derive at most four layers, and no more than 15 children are allowed in the first layer. __label__=other
The maximum number of children of a named entity in layer i is bounded by the number in layer (i-1) multiplying a decreasing rate. __label__=other
In the experiments, we set the decreasing rate to be 0.7, so that at most 15, 15×0.7, 15×0.7 2 , and 15×0.7 3 children can be expanded by a named entity in layers 0-3, respectively. __label__=result
We set the threshold θ at 0.1. __label__=method
Those named entities with CODC scores larger than the predefined threshold are sorted, and a sufficient number of named entities are selected in a sequence for expansion. __label__=other
In this way, a total of 7,642 nodes are generated by the 100 seeds. __label__=other
We employ Touch-Graph (http://www.touchgraph.com) to represent the named entity ontology. __label__=software
Figure 6shows an example by using " 湯姆克魯斯 " as a seed, which is a Mandarin transliteration name of an actor " Tom Cruise " , to build an ontology. __label__=other
To evaluate the performance, we consider the following four types. __label__=other
(1) Named Entity (NE) type: In this case, the proposed candidate should be a named entity and should not have incorrect boundary. __label__=other
A personal name with a title or a first name with more than 4 characters is regarded as being correct. __label__=other
In contrast, patterns with a last name only are considered incorrect. __label__=other
(2) Relational property of NE (RNE) type: For those acceptable strings in (1), which have the same relational property with the initial seed or its parents are considered to be correct. __label__=other
The remaining nodes are incorrect. __label__=other
(3) Partial Named Entity (PNE) type: We relax the restriction on boundary errors specified in (1). __label__=other
Patterns consisting of partial named entities are regarded as being correct. __label__=other
The remaining nodes are incorrect. __label__=other
(4) Relational property of PNE (RPNE) type: For those acceptable strings in (3), which have the same relational property with the initial seed or its parents are considered to be correct. __label__=other
The remaining nodes are incorrect. __label__=other
Table 6shows the performance in ontology generation. __label__=other
Of those 7,642 nodes, the error rates for the NE type, the RNE type, the PNE type, and the PRNE type are 19.60%, 34.20%, 12.62%, and 29.82%, respectively. __label__=result
In the previous experiments, we employed 51,111 transliteration names (BaselineTN) to build the bi-character language model. __label__=method
However, these transliteration names might not be active on the Web. __label__=other
We submitted these transliteration names to a search engine (i.e., Google). __label__=software
For a transliteration name, if the search engine does not return any web pages, we filter it out. __label__=other
Finally, we filter out 14,933 named entities and get 36,178 transliteration names (FilterTN) with this method. __label__=other
Refer to Table 6. __label__=other
Of the 7,642 named entities (Total-Ontology) reported by X ne -engine, 6,146 named entities (NE-Ontology) are of the correct NE type, and 5,023 named entities (RNE-Ontology) are of the correct RNE type. __label__=other
In the experiments, we consider word level accuracy only. __label__=other
Two basic transliteration name corpora, i.e., BaselineTN and FilterTN, are employed to build bi-character language models. __label__=other
In ideal case, correct syllables have been identified in the ASR (ASR_Perfect). __label__=other
Table  7shows that FilterTN is a little better than BaselineTN. __label__=other
We further combine FilterTN with the NE ontology derived by the X NE -Tree engine to perform evaluation. __label__=other
In this way, we employ the FilterTN+RNE-Ontology, FilterTN+NE-Ontology, and FilterTN+Total-Ontology to build bi-character language models. __label__=method
Table 7summarizes the experimental results obtained with the language model with the NE ontology. __label__=other
The three models with the NE ontology outperform the baseline model. __label__=result
In particular, the NE ontology improve the recall rate and the MRR from 0.79 and 0.50 (BaselineTN) to 0.84 and 0.55 (FilterTN+RNE-Ontology), respectively. __label__=result
Table 8lists the results obtained using both the NE ontology and error recovery procedure. __label__=other
The NE ontology is still helpful, in particular for the recall rate. __label__=other
In the best case, it improves the recall rate from 0.90 (BaselineTN) to 0.94 (FilterTN+RNE-Ontology). __label__=result
In summary, the model using NE ontology resources, the recall rate is improved 13.92%. __label__=result
On comparing the " FilterTN+RNE-Ontology " model with the ASR model without the error recovery procedure and NE ontology resources, the recall rate is improved 18.98%. __label__=result
Table 9summarizes the experimental results obtained with language models that use the NE ontology without/with error recovery procedure in the complete transliteration name ASR system. __label__=other
The system without the error recovery procedure (ASR Only), the NE ontology still improves the performance. __label__=result
Comparing the " FilterTN+RNE-Ontology " with BaselineTN, the recall rate is increased 15%. __label__=result
When the ASR system incorporates the error recovery procedure (ASR+Web), the recall rate is increased 14.28% (FilterTN+RNE-Ontology vs. BaselineTN). __label__=result
Spoken Transliteration Name Access  __label__=other
In this study, we employ the Web as a giant corpus to correct transliteration name recognition errors. __label__=objective
Web fuzzy search produces useful patterns for error recovery. __label__=result
In the ideal case, we input the correct syllable sequences, convert them into text strings, and test the recovery capability by using the Web corpus. __label__=other
On comparing with the model without the web recovery procedure, the recall rate is improved 13.92%. __label__=result
For collecting transliteration names beforehand, we propose using a named entity (NE) ontology generation engine, called the X NE -Tree engine. __label__=software
The engine automatically creates named entity ontology for a given seed. __label__=other
In the experiments, a total of 7,642 named entities in the ontology were initiated by 100 seeds. __label__=other
After the language model for speech recognition combined the named entity ontology, the recall rate is improved 18.98%. __label__=result
With a complete transliteration name ASR system, the error recovery experiments show that the recall rate is increased from 0.20 to 0.42 and the MRR from 0.07 to 0.31. __label__=result
When the RNE-Ontology is incorporated, the recall rate and the MRR is increased 0.48 and 0.38, respectively. __label__=result
Thus, we conclude that the error recovery procedure and NE ontology can helpful to the ASR model. __label__=result
Spoken Transliteration Name Access Appendix A * " 印、島、兒、猶、小、芮 " characters are not in training set and " 尼、妮 " , " 辛、新 " and " 奇、琪 " differentia of frequency is too high.  __label__=other
